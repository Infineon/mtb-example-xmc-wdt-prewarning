/******************************************************************************
* File Name:   main.c
*
* Description: This is the source code for the XMC MCU: WDT Prewarning example
*              for ModusToolbox.
*              Watchdog timer need to be feed every second for proper serving of WDT.
*              Pre-warning alarm is trigger in case Watchdog is not service inside serving window.
*              After the reset MCU checks the reason of last reset.
*              User LED blinks at faster rate due to the failure to feed WDT.
*
* Related Document: See README.md
*
******************************************************************************
*
* Copyright (c) 2015-2022, Infineon Technologies AG
* All rights reserved.
*
* Boost Software License - Version 1.0 - August 17th, 2003
*
* Permission is hereby granted, free of charge, to any person or organization
* obtaining a copy of the software and accompanying documentation covered by
* this license (the "Software") to use, reproduce, display, distribute,
* execute, and transmit the Software, and to prepare derivative works of the
* Software, and to permit third-parties to whom the Software is furnished to
* do so, all subject to the following:
*
* The copyright notices in the Software and this entire statement, including
* the above license grant, this restriction and the following disclaimer,
* must be included in all copies of the Software, in whole or in part, and
* all derivative works of the Software, unless such copies or derivative
* works are solely in the form of machine-executable object code generated by
* a source language processor.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
* SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
* FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
* ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
* DEALINGS IN THE SOFTWARE.
*
*****************************************************************************/
#include "cybsp.h"
#include "cy_utils.h"
#include <stdio.h>
#include "cy_retarget_io.h"
#include "xmc_wdt.h"
#include "xmc_scu.h"


/*******************************************************************************
* Macros
*******************************************************************************/
#if (UC_SERIES == XMC14)
#define COUNTS_DELAY                      (500000U)
#define WDT_Prewarning_Interrupt_Handler  IRQ1_Handler
#define INTERRUPT_PRIORITY_NODE_ID        IRQ1_IRQn
#endif

#if (UC_SERIES == XMC47)
#define WDT_Prewarning_Interrupt_Handler  NMI_Handler
#define COUNTS_DELAY                      (2000000U)
#endif

#define TICKS_PER_SECOND                  (1000U)
#define TICKS_WAIT                        (1000U)
#define MAX_NUM_FEEDS                     (10U)

/* Define macro to enable/disable printing of debug messages */
#define ENABLE_XMC_DEBUG_PRINT (0)

/* Define macro to set the loop count before printing debug messages */
#if ENABLE_XMC_DEBUG_PRINT
#define DEBUG_LOOP_COUNT_MAX                    2
static bool WDT_SERVICE_DONE = false;
#endif

/*******************************************************************************
* Data Structure
*******************************************************************************/
/* Structure for initializing watchdog timer*/
XMC_WDT_CONFIG_t wdt_config =
{
    .window_lower_bound  = 30000,    /*Lower bound for servicing window (WLB)--Range: [0H to FFFFFFFFH]*/
    .window_upper_bound  = 35000,    /*Upper bound for service window (WUB),Reset request is generated up on overflow of timer-Range: [0H to FFFFFFFFH]*/
    .service_pulse_width = 255,      /*Service Indication Pulse Width (SPW)-Range: [0H to FFH]*/
    .prewarn_mode        = true      /*Pre-warning mode (PRE). This accepts boolean values as input.*/
};

/*******************************************************************************
* Function Name: SysTick Handler
********************************************************************************
* Summary:
* This is the interrupt handler function for the System Tick interrupt.
*
* Parameters:
*  none
*
* Return:
*  void
*
*******************************************************************************/
void SysTick_Handler(void)
{
    static uint32_t ticks = 0;
    static uint32_t feeds = 0;

    ticks++;
    /* Watchdog is feed 10 times inside system handler ISR*/
    if (ticks == TICKS_WAIT && feeds < MAX_NUM_FEEDS)
    {
        /*User LED1 blinks 5 times*/
        XMC_GPIO_ToggleOutput(CYBSP_USER_LED_PORT, CYBSP_USER_LED1_PIN);
        /*Service watchdog when count value of watchdog timer is between lower and upper window bounds*/
        XMC_WDT_Service();

        #if ENABLE_XMC_DEBUG_PRINT
        WDT_SERVICE_DONE = true;
        #endif

        ticks = 0;

        feeds++;
    }
}

/*******************************************************************************
* Function Name: WDT_Prewarning_Interrupt_Handler
********************************************************************************
* Summary:
* This is the interrupt handler function for Watchdog Prewarning  interrupt.
*
* Parameters:
*  none
*
* Return:
*  void
*
*******************************************************************************/
void WDT_Prewarning_Interrupt_Handler(void)
{
    #if (UC_SERIES == XMC14)
    XMC_GPIO_ToggleOutput(CYBSP_USER_LED_PORT, CYBSP_USER_LED1_PIN);
    #else
    /*User LED2 toggle due to  Prewarning of WDT*/
    XMC_GPIO_ToggleOutput(CYBSP_USER_LED_PORT, CYBSP_USER_LED2_PIN);
    #endif
}

/*******************************************************************************
* Function Name: main
********************************************************************************
* Summary:
* This is the main function.
* The example feeds the watchdog 10 times (see blinking User LED1).
* The first crossing of the upper bound triggers an alarm.
* since pre-warning is enabled. The alarm signal is routed as a request to the SCU,
* where it is promoted to Interrupt event.
* In the Pre-warning Interrupt handler the User LED2 is toggle.
* Only the next overflow results a reset request.
* After the reset the device checks the reason for the last reset.
* If it was due to a failure to feed the WDT the User LED1 will blink rapidly.
*
* Parameters:
*  none
*
* Return:
*  int
*
*******************************************************************************/
int main(void)
{
    cy_rslt_t result;

    #if ENABLE_XMC_DEBUG_PRINT
    /* Assign false to disable printing of debug messages */
    static volatile bool debug_printf = true;
    #endif

    /*Initialize the device and board peripherals*/
    result = cybsp_init();
    if (result != CY_RSLT_SUCCESS)
    {
        CY_ASSERT(0);
    }

    /* Initialize printf retarget */
    cy_retarget_io_init(CYBSP_DEBUG_UART_HW);

    #if ENABLE_XMC_DEBUG_PRINT
    printf("Initialization done\r\n");
    #endif



    /*Check for the value representing the reason for device reset*/
    if ((XMC_SCU_RESET_GetDeviceResetReason() & XMC_SCU_RESET_REASON_WATCHDOG) != 0)
    {

        #if ENABLE_XMC_DEBUG_PRINT
        printf("Device reset\r\n");
        #endif

        /*Clear system reset status*/
        XMC_SCU_RESET_ClearDeviceResetReason();
        while(1)
        {
            /*Toggle User LED1 faster due to watchdog reset*/
            XMC_GPIO_ToggleOutput(CYBSP_USER_LED_PORT, CYBSP_USER_LED1_PIN);
            for (int i = 0; i < COUNTS_DELAY; ++i)
            {
                __NOP();
            }

        }
    }

    /*Clear system reset status*/
    XMC_SCU_RESET_ClearDeviceResetReason();

    #if (UC_SERIES == XMC47)
    /*Use standby clock as watchdog clock source*/
    XMC_SCU_HIB_EnableHibernateDomain();
    XMC_SCU_CLOCK_SetWdtClockSource(XMC_SCU_CLOCK_WDTCLKSRC_STDBY);
    XMC_SCU_CLOCK_EnableClock(XMC_SCU_CLOCK_WDT);
    #endif

    /*Promote the prewarning alarm event to SCU interrupt*/
    XMC_SCU_INTERRUPT_EnableEvent(XMC_SCU_INTERRUPT_EVENT_WDT_WARN);

    #if (UC_SERIES == XMC14)
    /*Enable Interrupt*/
    NVIC_EnableIRQ(INTERRUPT_PRIORITY_NODE_ID);
    #endif
   
    #if (UC_SERIES == XMC47)
    /*Enable NMI request*/
    XMC_SCU_INTERRUPT_EnableNmiRequest(XMC_SCU_NMIREQ_WDT_WARN);
    #endif

    /*Initializes and configures watchdog*/
    XMC_WDT_Init(&wdt_config);

    /*Start the watchdog timer*/
    XMC_WDT_Start();
    #if ENABLE_XMC_DEBUG_PRINT
    printf("WDT Started\r\n");
    #endif

    /*Feed the watchdog periodically every 1s*/
    SysTick_Config(SystemCoreClock / TICKS_PER_SECOND);

    #if ENABLE_XMC_DEBUG_PRINT
    debug_printf = false;
    #endif

    while(1)
    {
     /* Infinite loop */
        #if ENABLE_XMC_DEBUG_PRINT
        if(WDT_SERVICE_DONE && !debug_printf)
        {
            printf("WDT Serviced\r\n");
            debug_printf = true;
        }
        #endif

    }
}

/* [] END OF FILE */
